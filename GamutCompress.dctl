DEFINE_UI_PARAMS(cmethod, method, DCTLUI_COMBO_BOX, 0, {S, E, A, T}, {simple, exp, arctan, tanh});
DEFINE_UI_PARAMS(threshold, threshold, DCTLUI_SLIDER_FLOAT, 0.2f, 0.0f, 0.4f, 0.0f);
DEFINE_UI_PARAMS(cyan, cyan, DCTLUI_SLIDER_FLOAT, 0.25f, 0.0f, 1.0f, 0.0f);
DEFINE_UI_PARAMS(magenta, magenta, DCTLUI_SLIDER_FLOAT, 0.25f, 0.0f, 1.0f, 0.0f);
DEFINE_UI_PARAMS(yellow, yellow, DCTLUI_SLIDER_FLOAT, 0.25f, 0.0f, 1.0f, 0.0f);
DEFINE_UI_PARAMS(working_colorspace, working space, DCTLUI_COMBO_BOX, 0, {acescct, acescg}, {acescct, acescg});
DEFINE_UI_PARAMS(invert, invert, DCTLUI_CHECK_BOX, 0);

__CONSTANT__ float pi = 3.14159265359f;

// Convert acescg to acescct
__DEVICE__ float lin_to_acescct(float in) {
  if (in <= 0.0078125f) {
    return 10.5402377416545f * in + 0.0729055341958355f;
  } else {
    return (_log2f(in) + 9.72f) / 17.52f;
  }
}

// Convert acescct to acescg
__DEVICE__ float acescct_to_lin(float in) {
  if (in > 0.155251141552511f) {
    return _powf( 2.0f, in*17.52f - 9.72f);
  } else {
    return (in - 0.0729055341958355f) / 10.5402377416545f;
  }
}


// compression function which gives the y=1 x intersect at y=0
__DEVICE__ float f(float x, float k, float thr, int method) {
  if (method == 0) {
    return k;
  } else if (method == 1) {
    // natural exponent compression method
    return -_logf((-x+1)/(thr-x))*(-thr+x)+thr-k;
  } else if (method == 2) {
    // arctangent compression method
    return (2*_tanf( (pi*(1-thr))/(2*(x-thr)))*(x-thr))/pi+thr-k;
  } else if (method == 3) {
    // hyperbolic tangent compression method
    return _atanhf((1-thr)/(x-thr))*(x-thr)+thr-k;
  }
}

__DEVICE__ float bisect(float k, float thr, int method) {
  // use a simple bisection algorithm to bruteforce the root of f
  // returns an approximation of the value of limit 
  // such that the compression function intersects y=1 at desired value k
  // this allows us to specify the max distance we will compress to the gamut boundary

  // initial guess
  float a = 1.001f;
  float b = 100.0f;

  float c, v;
  float tolerance = 0.0001f;
  int nmax = 500; // max iterations
  int n = 0; // current iteration
  while (n <= nmax) {
    c = (a + b)/2; // midpoint between a and b
    v = f(c, k, thr, method); // function value
    if (v == 0 || (b-a)/2 < tolerance) {
      break; // result found: c will be returned after while loop
    }
    if (v > 0 && f(a, k, thr, method) > 0) {
      a = c; // c is new lower bound
    } else {
      b = c; // c is new upper bound
    }
    n += 1;
  }
  return c;
}


// calculate compressed distance
__DEVICE__ float compress(float dist, float lim, float thr, bool invert, int method) {
  float cdist;
  if (dist < thr) {
    cdist = dist;
  } else {
    if (method == 0) {
      // simple Reinhard type compression suggested by Nick Shaw and Lars Borg
      // https://community.acescentral.com/t/simplistic-gamut-mapping-approaches-in-nuke/2679/3
      // https://community.acescentral.com/t/rgb-saturation-gamut-mapping-approach-and-a-comp-vfx-perspective/2715/52
      // example plot: https://www.desmos.com/calculator/h2n8smtgkl
      if (invert == 0) {
        cdist = thr + 1/(1/(dist - thr) + 1/(1 - thr) - 1/(lim - thr));
      } else {
        cdist = thr + 1/(1/(dist - thr) - 1/(1 - thr) + 1/(lim - thr));
      }
    } else if (method == 1) {
      // natural exponent compression method: plot https://www.desmos.com/calculator/jf99glamuc
      if (invert == 0) {
        cdist = lim-(lim-thr)*exp(-(((dist-thr)*((1*lim)/(lim-thr))/lim)));
      } else {
        cdist = -log((dist-lim)/(thr-lim))*(-thr+lim)/1+thr;
      }
    } else if (method == 2) {
      // arctangent compression method: plot https://www.desmos.com/calculator/olmjgev3sl
      if (invert == 0) {
        cdist = thr + (lim - thr) * 2 / pi * atan(pi/2 * (dist - thr)/(lim - thr));
      } else {
        cdist = thr + (lim - thr) * 2 / pi * tan(pi/2 * (dist - thr)/(lim - thr));
      }
    } else if (method == 3) {
      // hyperbolic tangent compression method: plot https://www.desmos.com/calculator/sapcakq6t1
      if (invert == 0) {
        cdist = thr + (lim - thr) * tanh( ( (dist- thr)/( lim-thr)));
      } else {
        cdist = thr + (lim - thr) * atanh( dist/( lim - thr) - thr/( lim - thr));
      }
    }
  }
  return cdist;
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) 
{ 
  // ^-- this is necessary for the DCTL to work!

  // source pixels
  float3 rgb = make_float3(p_R, p_G, p_B);
  
  if (working_colorspace == acescct) {
    rgb.x = acescct_to_lin(rgb.x);
    rgb.y = acescct_to_lin(rgb.y);
    rgb.z = acescct_to_lin(rgb.z);
  }

  // set up method
  int method;
  if (cmethod == S) {
    method = 0;
  } else if (cmethod == E) {
    method = 1;
  } else if (cmethod == A) {
    method = 2;
  } else if (cmethod == T) {
    method = 3;
  }

  // thr is the percentage of the core gamut to protect: the complement of threshold.
  float thr = 1 - threshold;
  
  // lim is the max distance from the gamut boundary that will be compressed
  // 0 is a no-op, 1 will compress colors from a distance of 2.0 from achromatic to the gamut boundary
  // if method is Reinhard, use the limit as-is
  float3 lim;
  if (method == 0) {
    lim = make_float3(cyan+1, magenta+1, yellow+1);
  } else {
    // otherwise, we have to bruteforce the value of limit 
    // such that lim is the value of x where y=1 - also enforce sane ranges to avoid nans

    // Not sure of a way to pre-calculate a constant using the values from the ui parameters in Resolve DCTL...
    // This approach might have performance implications
    lim = make_float3(
      bisect(_fmaxf(0.0001f, cyan)+1, thr, method),
      bisect(_fmaxf(0.0001f, magenta)+1, thr, method),
      bisect(_fmaxf(0.0001f, yellow)+1, thr, method));
  }

  // achromatic axis 
  float ach = _fmaxf(rgb.x, _fmaxf(rgb.y, rgb.z));

  // distance from the achromatic axis for each color component aka inverse rgb ratios
  float3 dist;
  dist.x = _fabs(rgb.x-ach)/ach;
  dist.y = _fabs(rgb.y-ach)/ach;
  dist.z = _fabs(rgb.z-ach)/ach;

  // compress distance with user controlled parameterized shaper function
  float3 cdist = make_float3(
    compress(dist.x, lim.x, thr, invert, method),
    compress(dist.y, lim.y, thr, invert, method),
    compress(dist.z, lim.z, thr, invert, method));

  // recalculate rgb from compressed distance and achromatic
  // effectively this scales each color component relative to achromatic axis by the compressed distance
  float3 crgb = make_float3(
    ach-cdist.x*ach,
    ach-cdist.y*ach,
    ach-cdist.z*ach);

  if (working_colorspace == acescct) {
    crgb.x = lin_to_acescct(crgb.x);
    crgb.y = lin_to_acescct(crgb.y);
    crgb.z = lin_to_acescct(crgb.z);
  }

  // write output
  return crgb;
}