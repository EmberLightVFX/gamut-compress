set cut_paste_input [stack 0]
push $cut_paste_input
Group {
name GamutCompress_blink
label "\[value direction]"
addUserKnob {20 GamutCompress}
addUserKnob {7 threshold t "Percentage of the gamut to affect. A value of 0.2 will leave leave the core 80% of the colors within the gamut unaffected." R 0 0.2}
threshold 0.2
addUserKnob {26 limits_label l " " T <b>limits}
addUserKnob {7 cyan t "cyan limit" R 0.001 1}
cyan 0.2
addUserKnob {7 magenta t "magenta limit" R 0.001 1}
magenta 0.2
addUserKnob {7 yellow t "yellow limit" R 0.001 1}
yellow 0.2
addUserKnob {26 ""}
addUserKnob {4 direction M {forward inverse}}
}
Input {
inputs 0
name Input
xpos -40
ypos -10
}
AddChannels {
name AddChannels1
note_font Helvetica
xpos -40
ypos 26
}
BlinkScript {
KernelDescription "2 \"GamutCompression\" iterate pixelWise cab2e26c15bf9ddb76fea7e0d9f062067015b923be80c8e4816e596d2bc31261 2 \"src\" Read Point \"dst\" Write Point 5 \"threshold\" Float 1 AAAAAA== \"cyan\" Float 1 AAAAAA== \"magenta\" Float 1 AAAAAA== \"yellow\" Float 1 AAAAAA== \"invert\" Bool 1 AA== 5 \"threshold\" 1 1 \"cyan\" 1 1 \"magenta\" 1 1 \"yellow\" 1 1 \"invert\" 1 1 2 \"thr\" Float 1 1 AAAAAA== \"lim\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA=="
kernelSource "kernel GamutCompression : ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float threshold;\n    float cyan;\n    float magenta;\n    float yellow;\n    bool invert;\n\n  local:\n  float thr;\n  float3 lim;\n\n\n  void init() \{\n    // thr is the percentage of the core gamut to protect: the complement of threshold.\n    thr = 1.0f - threshold;\n    \n    // lim is the max distance from the gamut boundary that will be compressed\n    // 0 is a no-op, 1 will compress colors from a distance of 2.0 from achromatic to the gamut boundary\n    lim = float3(cyan+1.0f, magenta+1.0f, yellow+1.0f);\n  \}\n\n\n  // calc compressed distance\n  float3 compress(float3 dist) \{\n    float3 cdist;\n    float cd;\n\n    // simple Reinhard type compression suggested by Nick Shaw and Lars Borg\n      // https://community.acescentral.com/t/simplistic-gamut-mapping-approaches-in-nuke/2679/3\n      // https://community.acescentral.com/t/rgb-saturation-gamut-mapping-approach-and-a-comp-vfx-perspective/2715/52\n    // example plot: https://www.desmos.com/calculator/h2n8smtgkl\n\n    for (int i = 0; i < 3; i++) \{\n      if (dist\[i] < thr) \{\n        cd = dist\[i];\n      \} else \{\n        if (invert == 0.0f) \{\n          cd = thr + 1/(1/(dist\[i] - thr) + 1/(lim\[i] - thr));\n        \} else \{\n          cd = thr + 1/(1/(dist\[i] - thr) + -1/(lim\[i] - thr));\n        \}\n      \}\n      if (i==0)\{ cdist.x = cd; \} else if (i==1) \{ cdist.y = cd;\} else if (i==2) \{cdist.z = cd;\}\n    \}\n    return cdist;\n  \}\n\n\n  void process() \{\n    // source pixels\n    float3 rgb = float3(src().x, src().y, src().z);\n\n    // achromatic axis \n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n\n    // distance from the achromatic axis for each color component aka inverse rgb ratios\n    float3 dist = ach == 0.0f ? float3(0.0f, 0.0f, 0.0f) : fabs(rgb-ach)/ach;\n\n    // compress distance with user controlled parameterized shaper function\n    float3 cd = compress(dist);\n\n    // recalculate rgb from compressed distance and achromatic\n    // effectively this scales each color component relative to achromatic axis by the compressed distance\n    float3 c = ach-cd*ach;\n\n    // write output\n    dst() = float4(c.x, c.y, c.z, 1);\n  \}\n\};"
rebuild ""
GamutCompression_threshold {{parent.threshold}}
GamutCompression_cyan {{parent.cyan}}
GamutCompression_magenta {{parent.magenta}}
GamutCompression_yellow {{parent.yellow}}
GamutCompression_invert {{parent.direction}}
rebuild_finalise ""
name GamutCompress
selected true
xpos -40
ypos 82
}
Output {
name Output
xpos -40
ypos 134
}
end_group