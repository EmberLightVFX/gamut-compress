set cut_paste_input [stack 0]
push $cut_paste_input
Group {
 name GamutCompress_blink
 label "\[value method] : \[value direction]"
 addUserKnob {20 GamutCompress}
 addUserKnob {4 method t "the type of distance compression function you want to use" M {reinhard}}
 addUserKnob {22 reset -STARTLINE T "n = nuke.thisNode()\nknobs = \['threshold', 'cyan', 'magenta', 'yellow']\nfor k in knobs:\n    n\[k].setValue(0.2)"}
 addUserKnob {6 use_gpu l "use gpu" t "use gpu for blinkscript node" -STARTLINE}
 use_gpu true
 addUserKnob {7 threshold t "Percentage of the gamut to affect. A value of 0.2 will leave leave the core 80% of the colors within the gamut unaffected." R 0 0.2}
 threshold 0.2
 addUserKnob {26 distance_limit_label l " " t "Specifies the distance beyond the gamut boundary to map to the gamut boundary for each color component." T "<b>distance limit"}
 addUserKnob {7 cyan t "distance limit for the R component." R 0.001 1}
 cyan 0.2
 addUserKnob {7 magenta t "distance limit for the G component." R 0.001 1}
 magenta 0.2
 addUserKnob {7 yellow t "distance limit for the B component." R 0.001 1}
 yellow 0.2
 addUserKnob {26 ""}
 addUserKnob {4 direction M {forward inverse}}
 addUserKnob {20 info_tab l Info}
 addUserKnob {26 info_label l " " T "<style> a:link \{ color: #ccc \}</style>\n<font color=#ccc>\n<b>GamutCompress</b><br>\nmaps out of gamut colors back into gamut.<br><br>\n\n<b>Method</b><br>\nSpecify the tone compression curve to use when <br>\nmapping out of gamut colors into the boundary threshold.<br>\n<a href=https://www.desmos.com/calculator/lkhdtjbodx>reinhard</a>\n<br><br>\n\n<b>Threshold</b><br>\nPercentage of the gamut to affect. If threshold is 0.2, <br>\nthe inner 80% of the gamut will be unaffected and <br>\nout of gamut values will be compressed into <br>\nthe outer 20% of the gamut's color volume.<br><br>\n\n<b>Max Distance</b><br>\nPer color component control to specify what distance will be <br>\ncompressed to the gamut boundary. For example, <br>\na value of cyan=0.2 will map colors with a distance of red=1.2 from <br>\nthe achromatic axis to red=1.0, which is the gamut boundary.<br><br><br>\n\n<b>Direction</b><br>\nSpecifies whether to apply or inverse the gamut compression operation.\n<br><br>\n<a href=https://github.com/jedypod/gamut-compress>Additional Documentation</a><br><br>\n\nWritten by <a href=https://github.com/jedypod color=red>Jed Smith</a> with <a href=https://community.acescentral.com/t/rgb-saturation-gamut-mapping-approach-and-a-comp-vfx-perspective>help</a> from the <a href=https://community.acescentral.com/c/aces-development-acesnext/vwg-aces-gamut-mapping-working-group>ACES Gamut Mapping VWG</a>"}
}
 Input {
  inputs 0
  name Input
  xpos -40
  ypos -10
 }
 AddChannels {
  name AddChannels
  xpos -40
  ypos 26
 }
 BlinkScript {
  KernelDescription "2 \"GamutCompression\" iterate pixelWise 5eb4b372ffd8bca3b30b29aba3a43a234a5ee5dd25768f2ff32120bad65d1cf0 2 \"src\" Read Point \"dst\" Write Point 5 \"threshold\" Float 1 AAAAAA== \"cyan\" Float 1 AAAAAA== \"magenta\" Float 1 AAAAAA== \"yellow\" Float 1 AAAAAA== \"invert\" Bool 1 AA== 5 \"threshold\" 1 1 \"cyan\" 1 1 \"magenta\" 1 1 \"yellow\" 1 1 \"invert\" 1 1 2 \"thr\" Float 1 1 AAAAAA== \"lim\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel GamutCompression : ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float threshold;\n    float cyan;\n    float magenta;\n    float yellow;\n    bool invert;\n\n  local:\n  float thr;\n  float3 lim;\n\n\n  void init() \{\n    // thr is the percentage of the core gamut to protect: the complement of threshold.\n    thr = 1 - threshold;\n    \n    // lim is the max distance from the gamut boundary that will be compressed\n    // 0 is a no-op, 1 will compress colors from a distance of 2.0 from achromatic to the gamut boundary\n    lim = float3(cyan+1, magenta+1, yellow+1);\n  \}\n\n\n  // calc compressed distance\n  float3 compress(float3 dist) \{\n    float3 cdist;\n    float cd;\n\n    // simple Reinhard type compression suggested by Nick Shaw and Lars Borg\n      // https://community.acescentral.com/t/simplistic-gamut-mapping-approaches-in-nuke/2679/3\n      // https://community.acescentral.com/t/rgb-saturation-gamut-mapping-approach-and-a-comp-vfx-perspective/2715/52\n    // example plot: https://www.desmos.com/calculator/h2n8smtgkl\n\n    for (int i = 0; i < 3; i++) \{\n      if (dist\[i] < thr) \{\n        cd = dist\[i];\n      \} else \{\n        if (invert == 0) \{\n          cd = thr + 1/(1/(dist\[i] - thr) + 1/(1 - thr) - 1/(lim\[i] - thr));\n        \} else \{\n          cd = thr + 1/(1/(dist\[i] - thr) - 1/(1 - thr) + 1/(lim\[i] - thr));\n        \}\n      \}\n      if (i==0)\{ cdist.x = cd; \} else if (i==1) \{ cdist.y = cd;\} else if (i==2) \{cdist.z = cd;\}\n    \}\n    return cdist;\n  \}\n\n\n  void process() \{\n    // source pixels\n    float3 rgb = float3(src().x, src().y, src().z);\n\n    // achromatic axis \n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n\n    // distance from the achromatic axis for each color component aka inverse rgb ratios\n    float3 dist = ach == 0 ? float3(0, 0, 0) : fabs(rgb-ach)/ach;\n\n    // compress distance with user controlled parameterized shaper function\n    float3 cd = compress(dist);\n\n    // recalculate rgb from compressed distance and achromatic\n    // effectively this scales each color component relative to achromatic axis by the compressed distance\n    float3 c = ach-cd*ach;\n\n    // write output\n    dst() = float4(c.x, c.y, c.z, src().w);\n  \}\n\};"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  GamutCompression_threshold {{parent.threshold}}
  GamutCompression_cyan {{parent.cyan}}
  GamutCompression_magenta {{parent.magenta}}
  GamutCompression_yellow {{parent.yellow}}
  GamutCompression_invert {{parent.direction}}
  rebuild_finalise ""
  name GamutCompress
  selected true
  xpos -40
  ypos 80
 }
 Output {
  name Output
  xpos -40
  ypos 134
 }
end_group
